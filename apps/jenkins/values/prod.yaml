---
controller:
  # -- Used for label app.kubernetes.io/component
  componentName: "jenkins-controller"
  image:
    # -- Controller image registry
    registry: "docker.io"
    # -- Controller image repository
    repository: "jenkins/jenkins"

    # -- Controller image tag override; i.e., tag: "2.440.1-jdk21"
    tag: 2.504.1-lts-jdk21

    # -- Controller image tag label
    tagLabel: jdk21
    # -- Controller image pull policy
    pullPolicy: "Always"
  # -- Controller image pull secret
  imagePullSecretName:
  # -- Lifecycle specification for controller-container
  lifecycle: {}
  #  postStart:
  #    exec:
  #      command:
  #      - "uname"
  #      - "-a"

  # -- Append Jenkins labels to the controller
  customJenkinsLabels: []

  # When enabling LDAP or another non-Jenkins identity source, the built-in admin account will no longer exist.
  # If you disable the non-Jenkins identity store and instead use the Jenkins internal one,
  # you should revert controller.admin.username to your preferred admin user:
  admin:

    # -- The key in the existing admin secret containing the username
    userKey: username
    # -- The key in the existing admin secret containing the password
    passwordKey: password

    # The default configuration uses this secret to configure an admin user
    # If you don't need that user or use a different security realm, then you can disable it
    # -- Create secret for admin user
    createSecret: false

    # -- The name of an existing secret containing the admin credentials
    existingSecret:
  # -- Email address for the administrator of the Jenkins instance
  jenkinsAdminEmail:

  # This value should not be changed unless you use your custom image of jenkins or any derived from.
  # If you want to use Cloudbees Jenkins Distribution docker, you should set jenkinsHome: "/var/cloudbees-jenkins-distribution"
  # -- Custom Jenkins home path
  jenkinsHome: "/var/jenkins_home"

  # This value should not be changed unless you use your custom image of jenkins or any derived from.
  # If you want to use Cloudbees Jenkins Distribution docker, you should set jenkinsRef: "/usr/share/cloudbees-jenkins-distribution/ref"
  # -- Custom Jenkins reference path
  jenkinsRef: "/usr/share/jenkins/ref"

  # Path to the jenkins war file which is used by jenkins-plugin-cli.
  jenkinsWar: "/usr/share/jenkins/jenkins.war"
  # Override the default arguments passed to the war
  # overrideArgs:
  #   - --httpPort=8080

  # -- Resource allocation (Requests and Limits)
  resources:
    requests:
      cpu: "50m"
      memory: "256Mi"
    limits:
      cpu: "2000m"
      memory: "4096Mi"

  # Share process namespace to allow sidecar containers to interact with processes in other containers in the same pod
  shareProcessNamespace: false

  # -- Environment variable sources for Jenkins Container
  containerEnvFrom: []

  # -- Environment variables for Jenkins Container
  containerEnv: []
  #   - name: http_proxy
  #     value: "http://192.168.64.1:3128"

  # Set min/max heap here if needed with "-Xms512m -Xmx512m"
  # -- Append to `JAVA_OPTS` env var
  javaOpts:
  # -- Append to `JENKINS_OPTS` env var
  jenkinsOpts:

  # If you are using the ingress definitions provided by this chart via the `controller.ingress` block,
  # the configured hostname will be the ingress hostname starting with `https://`
  # or `http://` depending on the `tls` configuration.
  # The Protocol can be overwritten by specifying `controller.jenkinsUrlProtocol`.
  # -- Set protocol for Jenkins URL; `https` if `controller.ingress.tls`, `http` otherwise
  jenkinsUrlProtocol: https

  # -- Set Jenkins URL if you are not using the ingress definitions provided by the chart
  jenkinsUrl: https://${ARGOCD_ENV_JENKINS_LIVE_DOMAIN}

  # If you set this prefix and use ingress controller, then you might want to set the ingress path below
  # I.e., "/jenkins"
  # -- Root URI Jenkins will be served on
  jenkinsUriPrefix:


  # -- Jenkins controller service annotations
  serviceAnnotations: {}
  # -- Jenkins controller custom labels for the StatefulSet
  statefulSetLabels: {}
  #   foo: bar
  #   bar: foo
  # -- Labels for the Jenkins controller-service
  serviceLabels: {}
  #   service.beta.kubernetes.io/aws-load-balancer-backend-protocol: https

  # Put labels on Jenkins controller pod
  # -- Custom Pod labels (an object with `label-key: label-value` pairs)
  podLabels: {}

  # Enable Kubernetes Startup, Liveness and Readiness Probes
  # if Startup Probe is supported, enable it too
  # ~ 2 minutes to allow Jenkins to restart when upgrading plugins. Set ReadinessTimeout to be shorter than LivenessTimeout.
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes
  # -- Enable Kubernetes Probes configuration configured in `controller.probes`
  healthProbes: true

  probes:
    startupProbe:
      # -- Set the failure threshold for the startup probe
      failureThreshold: 12
      httpGet:
        # -- Set the Pod's HTTP path for the startup probe
        path: '{{ default "" .Values.controller.jenkinsUriPrefix }}/login'
        # -- Set the Pod's HTTP port to use for the startup probe
        port: http
      # -- Set the time interval between two startup probes executions in seconds
      periodSeconds: 10
      # -- Set the timeout for the startup probe in seconds
      timeoutSeconds: 5

    livenessProbe:
      # -- Set the failure threshold for the liveness probe
      failureThreshold: 5
      httpGet:
        # -- Set the Pod's HTTP path for the liveness probe
        path: '{{ default "" .Values.controller.jenkinsUriPrefix }}/login'
        # -- Set the Pod's HTTP port to use for the liveness probe
        port: http
      # -- Set the time interval between two liveness probes executions in seconds
      periodSeconds: 10
      # -- Set the timeout for the liveness probe in seconds
      timeoutSeconds: 5

      # If Startup Probe is not supported on your Kubernetes cluster, you might want to use "initialDelaySeconds" instead.
      # It delays the initial liveness probe while Jenkins is starting
      # -- Set the initial delay for the liveness probe in seconds
      initialDelaySeconds:

    readinessProbe:
      # -- Set the failure threshold for the readiness probe
      failureThreshold: 3
      httpGet:
        # -- Set the Pod's HTTP path for the liveness probe
        path: '{{ default "" .Values.controller.jenkinsUriPrefix }}/login'
        # -- Set the Pod's HTTP port to use for the readiness probe
        port: http
      # -- Set the time interval between two readiness probes executions in seconds
      periodSeconds: 10
      # -- Set the timeout for the readiness probe in seconds
      timeoutSeconds: 5

      # If Startup Probe is not supported on your Kubernetes cluster, you might want to use "initialDelaySeconds" instead.
      # It delays the initial readiness probe while Jenkins is starting
      # -- Set the initial delay for the readiness probe in seconds
      initialDelaySeconds:

  # PodDisruptionBudget config
  podDisruptionBudget:
    # ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/

    # -- Enable Kubernetes Pod Disruption Budget configuration
    enabled: false

    # For Kubernetes v1.5+, use 'policy/v1beta1'
    # For Kubernetes v1.21+, use 'policy/v1'
    # -- Policy API version
    apiVersion: "policy/v1beta1"

    annotations: {}
    labels: {}
    # -- Number of pods that can be unavailable. Either an absolute number or a percentage
    maxUnavailable: "0"

  # -- Create Agent listener service
  agentListenerEnabled: true
  # -- Listening port for agents
  agentListenerPort: 50000
  # -- Host port to listen for agents
  agentListenerHostPort:
  # -- Node port to listen for agents
  agentListenerNodePort:

  # ref: https://kubernetes.io/docs/concepts/services-networking/service/#traffic-policies
  # -- Traffic Policy of for the agentListener service
  agentListenerExternalTrafficPolicy:
  # -- Allowed inbound IP for the agentListener service
  agentListenerLoadBalancerSourceRanges:
    - 0.0.0.0/0
  # -- Disabled agent protocols
  disabledAgentProtocols:
    - JNLP-connect
    - JNLP2-connect
  csrf:
    defaultCrumbIssuer:
      # -- Enable the default CSRF Crumb issuer
      enabled: true
      # -- Enable proxy compatibility
      proxyCompatability: true

  # Kubernetes service type for the JNLP agent service
  # agentListenerServiceType is the Kubernetes Service type for the JNLP agent service,
  # either 'LoadBalancer', 'NodePort', or 'ClusterIP'
  # Note if you set this to 'LoadBalancer', you *must* define annotations to secure it. By default,
  # this will be an external load balancer and allowing inbound 0.0.0.0/0, a HUGE
  # security risk: https://github.com/kubernetes/charts/issues/1341
  # -- Defines how to expose the agentListener service
  agentListenerServiceType: "ClusterIP"

  # -- Annotations for the agentListener service
  agentListenerServiceAnnotations: {}

  # -- Optionally configure other ports to expose in the controller container
  extraPorts: []
  # - name: BuildInfoProxy
  #   port: 9000
  #   targetPort: 9010 (Optional: Use to explicitly set targetPort if different from port)

  # Plugins will be installed during Jenkins controller start
  # -- List of Jenkins plugins to install. If you don't want to install plugins, set it to `false`
  installPlugins:
    - kubernetes:4324.vfec199a_33512
    - workflow-aggregator:608.v67378e9d3db_1
    - github:1.43.0
    - git:5.7.0
    - github-branch-source:1815.v9152b_2ff7a_1b_
    - configuration-as-code:1963.v24e046127a_3f
    - antisamy-markup-formatter:173.v680e3a_b_69ff3

  # If set to false, Jenkins will download the minimum required version of all dependencies.
  # -- Download the minimum required version or latest version of all dependencies
  installLatestPlugins: true

  # -- List of plugins to install in addition to those listed in controller.installPlugins
  additionalPlugins: []

  # Without this; whenever the controller gets restarted (Evicted, etc.) it will fetch plugin updates that have the potential to cause breakage.
  # Note that for this to work, `persistence.enabled` needs to be set to `true`
  # -- Initialize only on first installation. Ensures plugins do not get updated inadvertently. Requires `persistence.enabled` to be set to `true`
  initializeOnce: true

  # Enable to always override the installed plugins with the values of 'controller.installPlugins' on upgrade or redeployment.
  # -- Overwrite installed plugins on start
  overwritePlugins: false

  # Configures if plugins bundled with `controller.image` should be overwritten with the values of 'controller.installPlugins' on upgrade or redeployment.
  # -- Overwrite plugins that are already installed in the controller image
  overwritePluginsFromImage: true

  # Configures the restrictions for naming projects. Set this key to null or empty to skip it in the default config.
  projectNamingStrategy: standard

  # Useful with ghprb plugin. The OWASP plugin is not installed by default, please update controller.installPlugins.
  # -- Enable HTML parsing using OWASP Markup Formatter Plugin (antisamy-markup-formatter)
  enableRawHtmlMarkupFormatter: true


  # Used to approve a list of groovy functions in pipelines used the script-security plugin. Can be viewed under /scriptApproval
  # -- List of groovy functions to approve
  scriptApproval: []
  #  - "method groovy.json.JsonSlurperClassic parseText java.lang.String"
  #  - "new groovy.json.JsonSlurperClassic"

  # -- Map of groovy init scripts to be executed during Jenkins controller start
  initScripts: {}
  #  test: |-
  #    print 'adding global pipeline libraries, register properties, bootstrap jobs...'
  # -- Name of the existing ConfigMap that contains init scripts
  initConfigMap:

  # 'name' is a name of an existing secret in the same namespace as jenkins,
  # 'keyName' is the name of one of the keys inside the current secret.
  # the 'name' and 'keyName' are concatenated with a '-' in between, so for example:
  # an existing secret "secret-credentials" and a key inside it named "github-password" should be used in JCasC as ${secret-credentials-github-password}
  # 'name' and 'keyName' must be lowercase RFC 1123 label must consist of lower case alphanumeric characters or '-',
  # and must start and end with an alphanumeric character (e.g. 'my-name', or '123-abc')
  # existingSecret existing secret "secret-credentials" and a key inside it named "github-username" should be used in JCasC as ${github-username}
  # When using existingSecret no need to specify the keyName under additionalExistingSecrets.
  existingSecret:

  # -- List of additional existing secrets to mount
  additionalExistingSecrets:
    - name: jenkins-github-app-raulstechtips
      keyName: appId
    - name: jenkins-github-app-raulstechtips
      keyName: owner
    - name: jenkins-github-app-raulstechtips
      keyName: privateKey
    - name: jenkins-github-app-raulstechtips
      keyName: pat
  # ref: https://github.com/jenkinsci/configuration-as-code-plugin/blob/master/docs/features/secrets.adoc#kubernetes-secrets
  # additionalExistingSecrets:
  #  - name: secret-name-1
  #    keyName: username
  #  - name: secret-name-1
  #    keyName: password

  # -- List of additional secrets to create and mount
  additionalSecrets: []
  # ref: https://github.com/jenkinsci/configuration-as-code-plugin/blob/master/docs/features/secrets.adoc#kubernetes-secrets
  # additionalSecrets:
  #  - name: nameOfSecret
  #    value: secretText


  # -- Name of default cloud configuration.
  cloudName: "kubernetes"

  # Below is the implementation of Jenkins Configuration as Code. Add a key under configScripts for each configuration area,
  # where each corresponds to a plugin or section of the UI. Each key (prior to | character) is just a label, and can be any value.
  # Keys are only used to give the section a meaningful name. The only restriction is they may only contain RFC 1123 \ DNS label
  # characters: lowercase letters, numbers, and hyphens. The keys become the name of a configuration yaml file on the controller in
  # /var/jenkins_home/casc_configs (by default) and will be processed by the Configuration as Code Plugin. The lines after each |
  # become the content of the configuration yaml file. The first line after this is a JCasC root element, e.g., jenkins, credentials,
  # etc. Best reference is https://<jenkins_url>/configuration-as-code/reference. The example below creates a welcome message:
  JCasC:
    # -- Enables default Jenkins configuration via configuration as code plugin
    defaultConfig: true

    # If true, the init container deletes all the plugin config files and Jenkins Config as Code overwrites any existing configuration
    # -- Whether Jenkins Config as Code should overwrite any existing configuration
    overwriteConfiguration: false
    # -- Remote URLs for configuration files.
    configUrls: []
    # - https://acme.org/jenkins.yaml
    # -- List of Jenkins Config as Code scripts
    configScripts:
      github-bootstrap: |
        credentials:
          system:
            domainCredentials:
              - credentials:
                - gitHubApp:
                    id: "github-app"
                    scope: GLOBAL
                    description: "GitHub App (GitOps bootstrap)"
                    appID: "${jenkins-github-app-raulstechtips-appId}"
                    owner: "${jenkins-github-app-raulstechtips-owner}"
                    privateKey: "${jenkins-github-app-raulstechtips-privateKey}"
              - credentials:
                - string
                  id: "github-app-pat"
                  scope: GLOBAL
                  description: "GitHub App PAT (GitOps bootstrap)"
                  value: "${jenkins-github-app-raulstechtips-pat}"
    #  welcome-message: |
    #    jenkins:
    #      systemMessage: Welcome to our CI\CD server. This Jenkins is configured and managed 'as code'.

    # Allows adding to the top-level security JCasC section. For legacy purposes, by default, the chart includes apiToken configurations
    # -- Jenkins Config as Code security-section
    security:
      apiToken:
        creationOfLegacyTokenEnabled: false
        tokenGenerationOnCreationEnabled: false
        usageStatisticsEnabled: true

    # Ignored if securityRealm is defined in controller.JCasC.configScripts
    # -- Jenkins Config as Code Security Realm-section
    securityRealm: |-
      local:
        allowsSignup: false
        enableCaptcha: false
        users:
        - id: "${chart-admin-username}"
          name: "Jenkins Admin"
          password: "${chart-admin-password}"

    # Ignored if authorizationStrategy is defined in controller.JCasC.configScripts
    # -- Jenkins Config as Code Authorization Strategy-section
    authorizationStrategy: |-
      loggedInUsersCanDoAnything:
        allowAnonymousRead: false

    # -- Annotations for the JCasC ConfigMap
    configMapAnnotations: {}

  # -- Custom init-container specification in raw-yaml format
  customInitContainers: []
  # - name: custom-init
  #   image: "alpine:3"
  #   imagePullPolicy: Always
  #   command: [ "uname", "-a" ]

  sidecars:
    configAutoReload:
      # If enabled: true, Jenkins Configuration as Code will be reloaded on-the-fly without a reboot.
      # If false or not-specified, JCasC changes will cause a reboot and will only be applied at the subsequent start-up.
      # Auto-reload uses the http://<jenkins_url>/reload-configuration-as-code endpoint to reapply config when changes to
      # the configScripts are detected.
      # -- Enables Jenkins Config as Code auto-reload
      enabled: true
      image:
        # -- Registry for the image that triggers the reload
        registry: docker.io
        # -- Repository of the image that triggers the reload
        repository: kiwigrid/k8s-sidecar
        # -- Tag for the image that triggers the reload
        tag: 1.30.3
      imagePullPolicy: IfNotPresent
      resources:
        limits:
          cpu: 100m
          memory: 100Mi
        requests:
          cpu: 50m
          memory: 50Mi
      # -- Enables additional volume mounts for the config auto-reload container
      additionalVolumeMounts: []
        #   - name: auto-reload-config
        #     mountPath: /var/config/logger
        #   - name: auto-reload-logs
        #     mountPath: /var/log/auto_reload
      # -- Config auto-reload logging settings
      logging:
        # See default settings https://github.com/kiwigrid/k8s-sidecar/blob/master/src/logger.py
        configuration:
          # -- Enables custom log config utilizing using the settings below.
          override: false
          logLevel: INFO
          formatter: JSON
          logToConsole: true
          logToFile: false
          maxBytes: 1024
          backupCount: 3

      # -- The scheme to use when connecting to the Jenkins configuration as code endpoint
      scheme: http
      # -- Skip TLS verification when connecting to the Jenkins configuration as code endpoint
      skipTlsVerify: false

      # -- How many connection-related errors to retry on
      reqRetryConnect: 10
      # -- How many seconds to wait before updating config-maps/secrets (sets METHOD=SLEEP on the sidecar)
      sleepTime:

      # -- Environment variable sources for the Jenkins Config as Code auto-reload container
      envFrom: []
      # -- Environment variables for the Jenkins Config as Code auto-reload container
      env: {}
      #   - name: REQ_TIMEOUT
      #     value: "30"

      # SSH port value can be set to any unused TCP port. The default, 1044, is a non-standard SSH port that has been chosen at random.
      # This is only used to reload JCasC config from the sidecar container running in the Jenkins controller pod.
      # This TCP port will not be open in the pod (unless you specifically configure this), so Jenkins will not be
      # accessible via SSH from outside the pod. Note if you use non-root pod privileges (runAsUser & fsGroup),
      # this must be > 1024:
      sshTcpPort: 1044
      # folder in the pod that should hold the collected dashboards:
      folder: "/var/jenkins_home/casc_configs"

      # If specified, the sidecar will search for JCasC config-maps inside this namespace.
      # Otherwise, the namespace in which the sidecar is running will be used.
      # It's also possible to specify ALL to search in all namespaces:
      # searchNamespace:
      # -- Enable container security context
      containerSecurityContext:
        readOnlyRootFilesystem: true
        allowPrivilegeEscalation: false

    # -- Configures additional sidecar container(s) for the Jenkins controller
    additionalSidecarContainers: []
    ## The example below runs the client for https://smee.io as sidecar container next to Jenkins,
    ## that allows triggering build behind a secure firewall.
    ## https://jenkins.io/blog/2019/01/07/webhook-firewalls/#triggering-builds-with-webhooks-behind-a-secure-firewall
    ##
    ## Note: To use it you should go to https://smee.io/new and update the url to the generated one.
    # - name: smee
    #   image: docker.io/twalter/smee-client:1.0.2
    #   args: ["--port", "{{ .Values.controller.servicePort }}", "--path", "/github-webhook/", "--url", "https://smee.io/new"]
    #   resources:
    #     limits:
    #       cpu: 50m
    #       memory: 128Mi
    #     requests:
    #       cpu: 10m
    #       memory: 32Mi

  # -- Name of the Kubernetes scheduler to use
  schedulerName: ""

  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  # -- Node labels for pod assignment
  nodeSelector: {}

  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
  # -- Toleration labels for pod assignment
  tolerations: []
  # -- Set TerminationGracePeriodSeconds
  terminationGracePeriodSeconds:
  # -- Set the termination message path
  terminationMessagePath:
  # -- Set the termination message policy
  terminationMessagePolicy:

  # -- Affinity settings
  affinity: {}

  # Leverage a priorityClass to ensure your pods survive resource shortages
  # ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/
  # -- The name of a `priorityClass` to apply to the controller pod
  priorityClassName:

  # -- Annotations for controller pod
  podAnnotations: {}
  # -- Annotations for controller StatefulSet
  statefulSetAnnotations: {}

  # ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  # -- Update strategy for StatefulSet
  updateStrategy: {}

  # -- Topology spread constraints
  topologySpreadConstraints: {}

  # Expose Prometheus metrics
  prometheus:
    # If enabled, add the prometheus plugin to the list of plugins to install
    # https://plugins.jenkins.io/prometheus

    # -- Enables prometheus service monitor
    enabled: false
    # -- Additional labels to add to the service monitor object
    serviceMonitorAdditionalLabels: {}
    # -- Set a custom namespace where to deploy ServiceMonitor resource
    serviceMonitorNamespace:
    # -- How often prometheus should scrape metrics
    scrapeInterval: 60s

    # Defaults to the default endpoint used by the prometheus plugin
    # -- The endpoint prometheus should get metrics from
    scrapeEndpoint: /prometheus

    # See here: https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/
    # The `groups` root object is added by default, add the rule entries
    # -- Array of prometheus alerting rules
    alertingrules: []
    # -- Additional labels to add to the PrometheusRule object
    alertingRulesAdditionalLabels: {}
    # -- Set a custom namespace where to deploy PrometheusRule resource
    prometheusRuleNamespace: ""

    # RelabelConfigs to apply to samples before scraping. Prometheus Operator automatically adds
    # relabelings for a few standard Kubernetes fields. The original scrape job’s name
    # is available via the __tmp_prometheus_job_name label.
    # More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    relabelings: []
    # MetricRelabelConfigs to apply to samples before ingestion.
    metricRelabelings: []

  # -- Can be used to disable rendering controller test resources when using helm template
  testEnabled: true


agent:
  # -- Enable Kubernetes plugin jnlp-agent podTemplate
  enabled: true
  # -- The name of the pod template to use for providing default values
  defaultsProviderTemplate: ""

  # Useful for not including a serviceAccount in the template if `false`
  # -- Use `serviceAccountAgent.name` as the default value for defaults template `serviceAccount`
  useDefaultServiceAccount: true

  # -- Override the default service account
  # @default -- `serviceAccountAgent.name` if `agent.useDefaultServiceAccount` is `true`
  serviceAccount:

  # For connecting to the Jenkins controller
  # -- Overrides the Kubernetes Jenkins URL
  jenkinsUrl: https://${ARGOCD_ENV_JENKINS_LIVE_DOMAIN}

  # -- Disables the verification of the controller certificate on remote connection. This flag correspond to the "Disable https certificate check" flag in kubernetes plugin UI
  skipTlsVerify: false
  # -- Enable the possibility to restrict the usage of this agent to specific folder. This flag correspond to the "Restrict pipeline support to authorized folders" flag in kubernetes plugin UI
  usageRestricted: false
  # -- The connection timeout in seconds for connections to Kubernetes API. The minimum value is 5
  kubernetesConnectTimeout: 5
  # -- The read timeout in seconds for connections to Kubernetes API. The minimum value is 15
  kubernetesReadTimeout: 15
  # -- The maximum concurrent connections to Kubernetes API
  maxRequestsPerHostStr: "32"
  # -- Time in minutes after which the Kubernetes cloud plugin will clean up an idle worker that has not already terminated
  retentionTimeout: 5
  # -- Seconds to wait for pod to be running
  waitForPodSec: 600
  # -- Namespace in which the Kubernetes agents should be launched
  namespace: jenkins
  # -- Custom Pod labels (an object with `label-key: label-value` pairs)
  podLabels: {}
  # -- Custom registry used to pull the agent jnlp image from
  jnlpregistry:
  image:
    # -- Repository to pull the agent jnlp image from
    repository: "jenkins/inbound-agent"
    # -- Tag of the image to pull
    tag: "3307.v632ed11b_3a_c7-2"
  # -- Configure working directory for default agent
  workingDir: "/home/jenkins/agent"
  nodeUsageMode: "NORMAL"
  # -- Append Jenkins labels to the agent
  customJenkinsLabels: []
  # -- Name of the secret to be used to pull the image
  imagePullSecretName:
  componentName: "jenkins-agent"

  # -- Resources allocation (Requests and Limits)
  resources:
    requests:
      cpu: "512m"
      memory: "512Mi"
      # ephemeralStorage:
    limits:
      cpu: "512m"
      memory: "512Mi"
      # ephemeralStorage:
  livenessProbe: {}
  #  execArgs: "cat /tmp/healthy"
  #  failureThreshold: 3
  #  initialDelaySeconds: 0
  #  periodSeconds: 10
  #  successThreshold: 1
  #  timeoutSeconds: 1

  # You may want to change this to true while testing a new image
  # -- Always pull agent container image before build
  alwaysPullImage: true
  # When using Pod Security Admission in the Agents namespace with the restricted Pod Security Standard,
  # the jnlp container cannot be scheduled without overriding its container definition with a securityContext.
  # This option allows to automatically inject in the jnlp container a securityContext
  # that is suitable for the use of the restricted Pod Security Standard.
  # -- Set a restricted securityContext on jnlp containers
  restrictedPssSecurityContext: false
  # Controls how agent pods are retained after the Jenkins build completes
  # Possible values: Always, Never, OnFailure
  podRetention: "Never"
  # Disable if you do not want the Yaml the agent pod template to show up
  # in the job Console Output. This can be helpful for either security reasons
  # or simply to clean up the output to make it easier to read.
  showRawYaml: false

  # You can define the volumes that you want to mount for this container
  # Allowed types are: ConfigMap, EmptyDir, EphemeralVolume, HostPath, Nfs, PVC, Secret
  # Configure the attributes as they appear in the corresponding Java class for that type
  # https://github.com/jenkinsci/kubernetes-plugin/tree/master/src/main/java/org/csanchez/jenkins/plugins/kubernetes/volumes
  # -- Additional volumes
  volumes: []
  # - type: ConfigMap
  #   configMapName: myconfigmap
  #   mountPath: /var/myapp/myconfigmap
  # - type: EmptyDir
  #   mountPath: /var/myapp/myemptydir
  #   memory: false
  # - type: EphemeralVolume
  #   mountPath: /var/myapp/myephemeralvolume
  #   accessModes: ReadWriteOnce
  #   requestsSize: 10Gi
  #   storageClassName: mystorageclass
  # - type: HostPath
  #   hostPath: /var/lib/containers
  #   mountPath: /var/myapp/myhostpath
  # - type: Nfs
  #   mountPath: /var/myapp/mynfs
  #   readOnly: false
  #   serverAddress: "192.0.2.0"
  #   serverPath: /var/lib/containers
  # - type: PVC
  #   claimName: mypvc
  #   mountPath: /var/myapp/mypvc
  #   readOnly: false
  # - type: Secret
  #   defaultMode: "600"
  #   mountPath: /var/myapp/mysecret
  #   secretName: mysecret
  # Pod-wide environment, these vars are visible to any container in the agent pod

  # You can define the workspaceVolume that you want to mount for this container
  # Allowed types are: DynamicPVC, EmptyDir, EphemeralVolume, HostPath, Nfs, PVC
  # Configure the attributes as they appear in the corresponding Java class for that type
  # https://github.com/jenkinsci/kubernetes-plugin/tree/master/src/main/java/org/csanchez/jenkins/plugins/kubernetes/volumes/workspace
  # -- Workspace volume (defaults to EmptyDir)
  workspaceVolume: {}
  ## DynamicPVC example
  # - type: DynamicPVC
  #   configMapName: myconfigmap
  ## EmptyDir example
  # - type: EmptyDir
  #   memory: false
  ## EphemeralVolume example
  # - type: EphemeralVolume
  #   accessModes: ReadWriteOnce
  #   requestsSize: 10Gi
  #   storageClassName: mystorageclass
  ## HostPath example
  # - type: HostPath
  #   hostPath: /var/lib/containers
  ## NFS example
  # - type: Nfs
  #   readOnly: false
  #   serverAddress: "192.0.2.0"
  #   serverPath: /var/lib/containers
  ## PVC example
  # - type: PVC
  #   claimName: mypvc
  #   readOnly: false

  # Pod-wide environment, these vars are visible to any container in the agent pod
  # -- Environment variables for the agent Pod
  envVars: []
  # - name: PATH
  #   value: /usr/local/bin
  # -- Mount a secret as environment variable
  secretEnvVars: []
  # - key: PATH
  #   optional: false # default: false
  #   secretKey: MY-K8S-PATH
  #   secretName: my-k8s-secret

  # -- Node labels for pod assignment
  nodeSelector: {}
  # Key Value selectors. Ex:
  # nodeSelector
  #   jenkins-agent: v1

  # -- Command to execute when side container starts
  command:
  # -- Arguments passed to command to execute
  args: "${computer.jnlpmac} ${computer.name}"
  # -- Side container name
  sideContainerName: "jnlp"

  # Doesn't allocate pseudo TTY by default
  # -- Allocate pseudo tty to the side container
  TTYEnabled: false
  # -- Max number of agents to launch for a whole cluster.
  containerCap: 10
  # -- Max number of agents to launch for this type of agent
  instanceCap: 2147483647
  # -- Agent Pod base name
  podName: "default"

  # Enables garbage collection of orphan pods for this Kubernetes cloud. (beta)
  garbageCollection:
    # -- When enabled, Jenkins will periodically check for orphan pods that have not been touched for the given timeout period and delete them.
    enabled: false
    # -- Namespaces to look at for garbage collection, in addition to the default namespace defined for the cloud. One namespace per line.
    namespaces: ""
    # namespaces: |-
    #   namespaceOne
    #   namespaceTwo
    # -- Timeout value for orphaned pods
    timeout: 300

  # -- Allows the Pod to remain active for reuse until the configured number of minutes has passed since the last step was executed on it
  idleMinutes: 0


  # The raw yaml of a Pod API Object, for example, this allows usage of toleration for agent pods.
  # https://github.com/jenkinsci/kubernetes-plugin#using-yaml-to-define-pod-templates
  # https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  # -- The raw yaml of a Pod API Object to merge into the agent spec
  yamlTemplate: ""
  # yamlTemplate: |-
  #   apiVersion: v1
  #   kind: Pod
  #   spec:
  #     tolerations:
  #     - key: "key"
  #       operator: "Equal"
  #       value: "value"

  # -- Defines how the raw yaml field gets merged with yaml definitions from inherited pod templates. Possible values: "merge" or "override"
  yamlMergeStrategy: "override"
  # -- Controls whether the defined yaml merge strategy will be inherited if another defined pod template is configured to inherit from the current one
  inheritYamlMergeStrategy: false
  # -- Timeout in seconds for an agent to be online
  connectTimeout: 100
  # -- Annotations to apply to the pod
  annotations: {}

  # Containers specified here are added to all agents. Set key empty to remove container from additional agents.
  # -- Add additional containers to the agents
  additionalContainers: []
  #  - sideContainerName: dind
  #    image:
  #      repository: docker
  #      tag: dind
  #    command: dockerd-entrypoint.sh
  #    args: ""
  #    privileged: true
  #    resources:
  #      requests:
  #        cpu: 500m
  #        memory: 1Gi
  #      limits:
  #        cpu: 1
  #        memory: 2Gi

  # Useful when configuring agents only with the podTemplates value, since the default podTemplate populated by values mentioned above will be excluded in the rendered template.
  # -- Disable the default Jenkins Agent configuration
  disableDefaultAgent: false

  # Below is the implementation of custom pod templates for the default configured kubernetes cloud.
  # Add a key under podTemplates for each pod template. Each key (prior to | character) is just a label, and can be any value.
  # Keys are only used to give the pod template a meaningful name. The only restriction is they may only contain RFC 1123 \ DNS label
  # characters: lowercase letters, numbers, and hyphens. Each pod template can contain multiple containers.
  # For this pod templates configuration to be loaded, the following values must be set:
  # controller.JCasC.defaultConfig: true
  # Best reference is https://<jenkins_url>/configuration-as-code/reference#Cloud-kubernetes. The example below creates a python pod template.
  # -- Configures extra pod templates for the default kubernetes cloud
  podTemplates: {}
  #  python: |
  #    - name: python
  #      label: jenkins-python
  #      serviceAccount: jenkins
  #      containers:
  #        - name: python
  #          image: python:3
  #          command: "/bin/sh -c"
  #          args: "cat"
  #          ttyEnabled: true
  #          privileged: true
  #          resourceRequestCpu: "400m"
  #          resourceRequestMemory: "512Mi"
  #          resourceLimitCpu: "1"
  #          resourceLimitMemory: "1024Mi"

# Inherits all values from `agent` so you only need to specify values which differ
# -- Configure additional
additionalAgents: {}
#  maven:
#    podName: maven
#    customJenkinsLabels: maven
#    # An example of overriding the jnlp container
#    # sideContainerName: jnlp
#    image:
#      repository: jenkins/jnlp-agent-maven
#      tag: latest
#  python:
#    podName: python
#    customJenkinsLabels: python
#    sideContainerName: python
#    image:
#      repository: python
#      tag: "3"
#    command: "/bin/sh -c"
#    args: "cat"
#    TTYEnabled: true


persistence:
  # -- Enable the use of a Jenkins PVC
  enabled: true

  # jenkins data Persistent Volume Storage Class
  # If defined, storageClassName: <storageClass>
  # If set to "-", storageClassName: "", which disables dynamic provisioning
  # If undefined (the default) or set to null, no storageClassName spec is
  #   set, choosing the default provisioner (gp2 on AWS, standard on GKE, AWS & OpenStack)
  # -- Storage class for the PVC
  storageClass: longhorn-jenkins
  # -- Annotations for the PVC
  annotations: {}
  # -- Labels for the PVC
  labels: {}
  # -- The PVC access mode
  accessMode: "ReadWriteOnce"
  # -- The size of the PVC
  size: "20Gi"

  # ref: https://kubernetes.io/docs/concepts/storage/volume-pvc-datasource/
  # -- Existing data source to clone PVC from
  dataSource: {}
  #   name: PVC-NAME
  #   kind: PersistentVolumeClaim

  # -- SubPath for jenkins-home mount
  subPath:
  # -- Additional volumes
  volumes: []
  #  - name: nothing
  #    emptyDir: {}

  # -- Additional mounts
  mounts: []
  #  - mountPath: /var/nothing
  #    name: nothing
  #    readOnly: true

networkPolicy:
  # -- Enable the creation of NetworkPolicy resources
  enabled: false

  # For Kubernetes v1.4, v1.5 and v1.6, use 'extensions/v1beta1'
  # For Kubernetes v1.7, use 'networking.k8s.io/v1'
  # -- NetworkPolicy ApiVersion
  apiVersion: networking.k8s.io/v1
  # You can allow agents to connect from both within the cluster (from within specific/all namespaces) AND/OR from a given external IP range
  internalAgents:
    # -- Allow internal agents (from the same cluster) to connect to controller. Agent pods will be filtered based on PodLabels
    allowed: true
    # -- A map of labels (keys/values) that agent pods must have to be able to connect to controller
    podLabels: {}
    # -- A map of labels (keys/values) that agents namespaces must have to be able to connect to controller
    namespaceLabels: {}
      # project: myproject
  externalAgents:
    # -- The IP range from which external agents are allowed to connect to controller, i.e., 172.17.0.0/16
    ipCIDR:
    # -- A list of IP sub-ranges to be excluded from the allowlisted IP range
    except: []
      # - 172.17.1.0/24

## Install Default RBAC roles and bindings
rbac:
  # -- Whether RBAC resources are created
  create: true
  # -- Whether the Jenkins service account should be able to read Kubernetes secrets
  readSecrets: false
  # -- Whether the Jenkins service account should be able to use the OpenShift "nonroot" Security Context Constraints
  useOpenShiftNonRootSCC: false

serviceAccount:
  # -- Configures if a ServiceAccount with this name should be created
  create: true

  # The name of the ServiceAccount is autogenerated by default
  #  -- The name of the ServiceAccount to be used by access-controlled resources
  name:
  # -- Configures annotations for the ServiceAccount
  annotations: {}
  # -- Configures extra labels for the ServiceAccount
  extraLabels: {}
  # -- Controller ServiceAccount image pull secret
  imagePullSecretName:
  # -- Auto-mount ServiceAccount token
  automountServiceAccountToken: true


serviceAccountAgent:
  # -- Configures if an agent ServiceAccount should be created
  create: false

  # If not set and create is true, a name is generated using the fullname template
  # -- The name of the agent ServiceAccount to be used by access-controlled resources
  name:
  # -- Configures annotations for the agent ServiceAccount
  annotations: {}
  # -- Configures extra labels for the agent ServiceAccount
  extraLabels: {}
  # -- Agent ServiceAccount image pull secret
  imagePullSecretName:
  # -- Auto-mount ServiceAccount token
  automountServiceAccountToken: true

# -- Checks if any deprecated values are used
checkDeprecation: true


# Here you can configure unit tests values when executing the helm unittest in the CONTRIBUTING.md
helmtest:
  # A testing framework for bash
  bats:
    # Bash Automated Testing System (BATS)
    image:
      # -- Registry of the image used to test the framework
      registry: "docker.io"
      # -- Repository of the image used to test the framework
      repository: "bats/bats"
      # -- Tag of the image to test the framework
      tag: "1.11.1"
